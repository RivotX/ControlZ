{"version":3,"sources":["../src/utils.ts","../src/more-itertools.ts","../src/itertools.ts","../src/builtins.ts","../src/custom.ts"],"sourcesContent":["import type { Primitive } from \"./types\";\n\ntype CmpFn<T> = (a: T, b: T) => number;\n\nexport function keyToCmp<T>(keyFn: (item: T) => Primitive): CmpFn<T> {\n  return (a: T, b: T) => {\n    const ka = keyFn(a);\n    const kb = keyFn(b);\n    // istanbul ignore else -- @preserve\n    if (typeof ka === \"boolean\" && typeof kb === \"boolean\") {\n      return ka === kb ? 0 : !ka && kb ? -1 : 1;\n    } else if (typeof ka === \"number\" && typeof kb === \"number\") {\n      return ka - kb;\n    } else if (typeof ka === \"string\" && typeof kb === \"string\") {\n      return ka === kb ? 0 : ka < kb ? -1 : 1;\n    } else {\n      return -1;\n    }\n  };\n}\n\nexport function identityPredicate(x: unknown): boolean {\n  return !!x;\n}\n\nexport function numberIdentity(x: unknown): number {\n  // istanbul ignore if -- @preserve\n  if (typeof x !== \"number\") {\n    throw new Error(\"Inputs must be numbers\");\n  }\n  return x;\n}\n\nexport function primitiveIdentity<P extends Primitive>(x: P): P;\nexport function primitiveIdentity(x: unknown): Primitive;\nexport function primitiveIdentity(x: unknown): Primitive {\n  // istanbul ignore if -- @preserve\n  if (typeof x !== \"string\" && typeof x !== \"number\" && typeof x !== \"boolean\") {\n    throw new Error(\"Please provide a key function that can establish object identity\");\n  }\n  return x;\n}\n","import { iter, map } from \"./builtins\";\nimport { izip, repeat } from \"./itertools\";\nimport type { Predicate, Primitive } from \"./types\";\nimport { primitiveIdentity } from \"./utils\";\n\n/**\n * Break iterable into lists of length `size`:\n *\n *     [...chunked([1, 2, 3, 4, 5, 6], 3)]\n *     // [[1, 2, 3], [4, 5, 6]]\n *\n * If the length of iterable is not evenly divisible by `size`, the last returned\n * list will be shorter:\n *\n *     [...chunked([1, 2, 3, 4, 5, 6, 7, 8], 3)]\n *     // [[1, 2, 3], [4, 5, 6], [7, 8]]\n */\nexport function* chunked<T>(iterable: Iterable<T>, size: number): Iterable<T[]> {\n  if (size < 1) {\n    throw new Error(`Invalid chunk size: ${size}`);\n  }\n\n  const it = iter(iterable);\n  for (;;) {\n    const chunk = take(size, it);\n    if (chunk.length > 0) {\n      yield chunk;\n    }\n    if (chunk.length < size) {\n      return;\n    }\n  }\n}\n\n/**\n * Return an iterator flattening one level of nesting in a list of lists:\n *\n *     [...flatten([[0, 1], [2, 3]])]\n *     // [0, 1, 2, 3]\n *\n */\nexport function* flatten<T>(iterableOfIterables: Iterable<Iterable<T>>): Iterable<T> {\n  for (const iterable of iterableOfIterables) {\n    for (const item of iterable) {\n      yield item;\n    }\n  }\n}\n\n/**\n * Intersperse filler element `value` among the items in `iterable`.\n *\n *     >>> [...intersperse(-1, range(1, 5))]\n *     [1, -1, 2, -1, 3, -1, 4]\n *\n */\nexport function intersperse<T, V>(value: V, iterable: Iterable<T>): Iterable<T | V> {\n  const stream = flatten(izip(repeat(value), iterable));\n  take(1, stream); // eat away and discard the first value from the output\n  return stream;\n}\n\n/**\n * Returns an iterable containing only the first `n` elements of the given\n * iterable.\n */\nexport function* itake<T>(n: number, iterable: Iterable<T>): Iterable<T> {\n  const it = iter(iterable);\n  let count = n;\n  while (count-- > 0) {\n    const s = it.next();\n    if (!s.done) {\n      yield s.value;\n    } else {\n      // Iterable exhausted, quit early\n      return;\n    }\n  }\n}\n\n/**\n * Returns an iterator of paired items, overlapping, from the original.  When\n * the input iterable has a finite number of items `n`, the outputted iterable\n * will have `n - 1` items.\n *\n *     >>> pairwise([8, 2, 0, 7])\n *     [(8, 2), (2, 0), (0, 7)]\n *\n */\nexport function* pairwise<T>(iterable: Iterable<T>): Iterable<[T, T]> {\n  const it = iter(iterable);\n  const first = it.next();\n  if (first.done) {\n    return;\n  }\n\n  let r1: T = first.value;\n  for (const r2 of it) {\n    yield [r1, r2];\n    r1 = r2;\n  }\n}\n\n/**\n * Returns a 2-tuple of arrays.  Splits the elements in the input iterable into\n * either of the two arrays.  Will fully exhaust the input iterable.  The first\n * array contains all items that match the predicate, the second the rest:\n *\n *     >>> const isOdd = x => x % 2 !== 0;\n *     >>> const iterable = range(10);\n *     >>> const [odds, evens] = partition(iterable, isOdd);\n *     >>> odds\n *     [1, 3, 5, 7, 9]\n *     >>> evens\n *     [0, 2, 4, 6, 8]\n *\n */\nexport function partition<T, N extends T>(\n  iterable: Iterable<T>,\n  predicate: (item: T) => item is N,\n): [N[], Exclude<T, N>[]];\nexport function partition<T>(iterable: Iterable<T>, predicate: Predicate<T>): [T[], T[]];\nexport function partition<T>(iterable: Iterable<T>, predicate: Predicate<T>): [T[], T[]] {\n  const good = [];\n  const bad = [];\n\n  for (const item of iterable) {\n    if (predicate(item)) {\n      good.push(item);\n    } else {\n      bad.push(item);\n    }\n  }\n\n  return [good, bad];\n}\n\n/**\n * Yields the next item from each iterable in turn, alternating between them.\n * Continues until all items are exhausted.\n *\n *     >>> [...roundrobin([1, 2, 3], [4], [5, 6, 7, 8])]\n *     [1, 4, 5, 2, 6, 3, 7, 8]\n */\nexport function* roundrobin<T>(...iters: Iterable<T>[]): Iterable<T> {\n  // We'll only keep lazy versions of the input iterables in here that we'll\n  // slowly going to exhaust.  Once an iterable is exhausted, it will be\n  // removed from this list.  Once the entire list is empty, this algorithm\n  // ends.\n  const iterables: Array<Iterator<T>> = map(iters, iter);\n\n  while (iterables.length > 0) {\n    let index = 0;\n    while (index < iterables.length) {\n      const it = iterables[index];\n      const result = it.next();\n\n      if (!result.done) {\n        yield result.value;\n        index++;\n      } else {\n        // This iterable is exhausted, make sure to remove it from the\n        // list of iterables.  We'll splice the array from under our\n        // feet, and NOT advancing the index counter.\n        iterables.splice(index, 1); // intentional side-effect!\n      }\n    }\n  }\n}\n\n/**\n * Yields the heads of all of the given iterables.  This is almost like\n * `roundrobin()`, except that the yielded outputs are grouped in to the\n * \"rounds\":\n *\n *     >>> [...heads([1, 2, 3], [4], [5, 6, 7, 8])]\n *     [[1, 4, 5], [2, 6], [3, 7], [8]]\n *\n * This is also different from `zipLongest()`, since the number of items in\n * each round can decrease over time, rather than being filled with a filler.\n */\nexport function* heads<T>(...iters: Array<Iterable<T>>): Iterable<T[]> {\n  // We'll only keep lazy versions of the input iterables in here that we'll\n  // slowly going to exhaust.  Once an iterable is exhausted, it will be\n  // removed from this list.  Once the entire list is empty, this algorithm\n  // ends.\n  const iterables: Array<Iterator<T>> = map(iters, iter);\n\n  while (iterables.length > 0) {\n    let index = 0;\n    const round = [];\n    while (index < iterables.length) {\n      const it = iterables[index];\n      const result = it.next();\n\n      if (!result.done) {\n        round.push(result.value);\n        index++;\n      } else {\n        // This iterable is exhausted, make sure to remove it from the\n        // list of iterables.  We'll splice the array from under our\n        // feet, and NOT advancing the index counter.\n        iterables.splice(index, 1); // intentional side-effect!\n      }\n    }\n    if (round.length > 0) {\n      yield round;\n    }\n  }\n}\n\n/**\n * Non-lazy version of itake().\n */\nexport function take<T>(n: number, iterable: Iterable<T>): T[] {\n  return Array.from(itake(n, iterable));\n}\n\n/**\n * Yield unique elements, preserving order.\n *\n *     >>> [...uniqueEverseen('AAAABBBCCDAABBB')]\n *     ['A', 'B', 'C', 'D']\n *     >>> [...uniqueEverseen('AbBCcAB', s => s.toLowerCase())]\n *     ['A', 'b', 'C']\n *\n */\nexport function* uniqueEverseen<T>(\n  iterable: Iterable<T>,\n  keyFn: (item: T) => Primitive = primitiveIdentity,\n): Iterable<T> {\n  const seen = new Set();\n  for (const item of iterable) {\n    const key = keyFn(item);\n    if (!seen.has(key)) {\n      seen.add(key);\n      yield item;\n    }\n  }\n}\n\n/**\n * Yields elements in order, ignoring serial duplicates.\n *\n *     >>> [...uniqueJustseen('AAAABBBCCDAABBB')]\n *     ['A', 'B', 'C', 'D', 'A', 'B']\n *     >>> [...uniqueJustseen('AbBCcAB', s => s.toLowerCase())]\n *     ['A', 'b', 'C', 'A', 'B']\n *\n */\nexport function* uniqueJustseen<T>(\n  iterable: Iterable<T>,\n  keyFn: (item: T) => Primitive = primitiveIdentity,\n): Iterable<T> {\n  let last = undefined;\n  for (const item of iterable) {\n    const key = keyFn(item);\n    if (key !== last) {\n      yield item;\n      last = key;\n    }\n  }\n}\n","import { enumerate, every, iter, range } from \"./builtins\";\nimport { flatten } from \"./more-itertools\";\nimport type { Predicate, Primitive } from \"./types\";\nimport { primitiveIdentity } from \"./utils\";\n\nconst SENTINEL = Symbol();\n\n/**\n * Returns an iterator that returns elements from the first iterable until it\n * is exhausted, then proceeds to the next iterable, until all of the iterables\n * are exhausted.  Used for treating consecutive sequences as a single\n * sequence.\n */\nexport function chain<T>(...iterables: Iterable<T>[]): Iterable<T> {\n  return flatten(iterables);\n}\n\n/**\n * Returns an iterator that counts up values starting with number `start`\n * (default 0), incrementing by `step`.  To decrement, use a negative step\n * number.\n */\nexport function* count(start = 0, step = 1): Iterable<number> {\n  let n = start;\n  for (;;) {\n    yield n;\n    n += step;\n  }\n}\n\n/**\n * Non-lazy version of icompress().\n */\nexport function compress<T>(data: Iterable<T>, selectors: Iterable<boolean>): T[] {\n  return Array.from(icompress(data, selectors));\n}\n\n/**\n * Returns an iterator producing elements from the iterable and saving a copy\n * of each.  When the iterable is exhausted, return elements from the saved\n * copy.  Repeats indefinitely.\n */\nexport function* cycle<T>(iterable: Iterable<T>): Iterable<T> {\n  const saved = [];\n  for (const element of iterable) {\n    yield element;\n    saved.push(element);\n  }\n\n  while (saved.length > 0) {\n    for (const element of saved) {\n      yield element;\n    }\n  }\n}\n\n/**\n * Returns an iterator that drops elements from the iterable as long as the\n * predicate is true; afterwards, returns every remaining element.  Note, the\n * iterator does not produce any output until the predicate first becomes\n * false.\n */\nexport function* dropwhile<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n  const it = iter(iterable);\n  let res: IteratorResult<T>;\n  while (!(res = it.next()).done) {\n    const value = res.value;\n    if (!predicate(value)) {\n      yield value;\n      break; // we break, so we cannot use a for..of loop!\n    }\n  }\n\n  for (const value of it) {\n    yield value;\n  }\n}\n\nexport function* groupby<T, K extends Primitive>(\n  iterable: Iterable<T>,\n  keyFn: (item: T) => K = primitiveIdentity,\n): Generator<[K, Generator<T, undefined>], undefined> {\n  const it = iter(iterable);\n\n  let currentValue: T;\n  let currentKey: K = SENTINEL as unknown as K;\n  //                           ^^^^^^^^^^^^^^^ Hack!\n  let targetKey: K = currentKey;\n\n  const grouper = function* grouper(tgtKey: K): Generator<T, undefined> {\n    while (currentKey === tgtKey) {\n      yield currentValue;\n\n      const nextVal = it.next();\n      if (nextVal.done) return;\n      currentValue = nextVal.value;\n      currentKey = keyFn(currentValue);\n    }\n  };\n\n  for (;;) {\n    while (currentKey === targetKey) {\n      const nextVal = it.next();\n      if (nextVal.done) {\n        currentKey = SENTINEL as unknown as K;\n        //                    ^^^^^^^^^^^^^^^ Hack!\n        return;\n      }\n      currentValue = nextVal.value;\n      currentKey = keyFn(currentValue);\n    }\n\n    targetKey = currentKey;\n    yield [currentKey, grouper(targetKey)];\n  }\n}\n\n/**\n * Returns an iterator that filters elements from data returning only those\n * that have a corresponding element in selectors that evaluates to `true`.\n * Stops when either the data or selectors iterables has been exhausted.\n */\nexport function* icompress<T>(data: Iterable<T>, selectors: Iterable<boolean>): Iterable<T> {\n  for (const [d, s] of izip(data, selectors)) {\n    if (s) {\n      yield d;\n    }\n  }\n}\n\n/**\n * Returns an iterator that filters elements from iterable returning only those\n * for which the predicate is true.\n */\nexport function ifilter<T, N extends T>(iterable: Iterable<T>, predicate: (item: T) => item is N): Iterable<N>;\nexport function ifilter<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T>;\nexport function* ifilter<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n  for (const value of iterable) {\n    if (predicate(value)) {\n      yield value;\n    }\n  }\n}\n\n/**\n * Returns an iterator that computes the given mapper function using arguments\n * from each of the iterables.\n */\nexport function* imap<T, V>(iterable: Iterable<T>, mapper: (item: T) => V): Iterable<V> {\n  for (const value of iterable) {\n    yield mapper(value);\n  }\n}\n\n/**\n * Returns an iterator that returns selected elements from the iterable.  If\n * `start` is non-zero, then elements from the iterable are skipped until start\n * is reached.  Then, elements are returned by making steps of `step` (defaults\n * to 1).  If set to higher than 1, items will be skipped.  If `stop` is\n * provided, then iteration continues until the iterator reached that index,\n * otherwise, the iterable will be fully exhausted.  `islice()` does not\n * support negative values for `start`, `stop`, or `step`.\n */\nexport function islice<T>(iterable: Iterable<T>, stop: number): Iterable<T>;\nexport function islice<T>(iterable: Iterable<T>, start: number, stop?: number | null, step?: number): Iterable<T>;\nexport function* islice<T>(\n  iterable: Iterable<T>,\n  stopOrStart: number,\n  possiblyStop?: number | null,\n  step = 1,\n): Iterable<T> {\n  let start, stop;\n  if (possiblyStop !== undefined) {\n    // islice(iterable, start, stop[, step])\n    start = stopOrStart;\n    stop = possiblyStop;\n  } else {\n    // islice(iterable, stop)\n    start = 0;\n    stop = stopOrStart;\n  }\n\n  if (start < 0) throw new Error(\"start cannot be negative\");\n  if (stop !== null && stop < 0) throw new Error(\"stop cannot be negative\");\n  if (step <= 0) throw new Error(\"step cannot be negative\");\n\n  let i = -1;\n  const it = iter(iterable);\n  let res: IteratorResult<T>;\n  while (true) {\n    i++;\n    if (stop !== null && i >= stop) return; // early returns, so we cannot use a for..of loop!\n\n    res = it.next();\n    if (res.done) return;\n\n    if (i < start) continue;\n    if ((i - start) % step === 0) {\n      yield res.value;\n    }\n  }\n}\n\n/**\n * Returns an iterator that aggregates elements from each of the iterables.\n * Used for lock-step iteration over several iterables at a time.  When\n * iterating over two iterables, use `izip2`.  When iterating over three\n * iterables, use `izip3`, etc.  `izip` is an alias for `izip2`.\n */\nexport function* izip2<T1, T2>(xs: Iterable<T1>, ys: Iterable<T2>): Iterable<[T1, T2]> {\n  const ixs = iter(xs);\n  const iys = iter(ys);\n  for (;;) {\n    const x = ixs.next();\n    const y = iys.next();\n    if (!x.done && !y.done) {\n      yield [x.value, y.value];\n    } else {\n      // One of the iterables exhausted\n      return;\n    }\n  }\n}\n\n/**\n * Like izip2, but for three input iterables.\n */\nexport function* izip3<T1, T2, T3>(xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Iterable<[T1, T2, T3]> {\n  const ixs = iter(xs);\n  const iys = iter(ys);\n  const izs = iter(zs);\n  for (;;) {\n    const x = ixs.next();\n    const y = iys.next();\n    const z = izs.next();\n    if (!x.done && !y.done && !z.done) {\n      yield [x.value, y.value, z.value];\n    } else {\n      // One of the iterables exhausted\n      return;\n    }\n  }\n}\n\nexport const izip = izip2;\n\n/**\n * Returns an iterator that aggregates elements from each of the iterables.  If\n * the iterables are of uneven length, missing values are filled-in with\n * fillvalue.  Iteration continues until the longest iterable is exhausted.\n */\nexport function* izipLongest2<T1, T2, D>(xs: Iterable<T1>, ys: Iterable<T2>, filler?: D): Iterable<[T1 | D, T2 | D]> {\n  const filler_ = filler as D;\n  const ixs = iter(xs);\n  const iys = iter(ys);\n  for (;;) {\n    const x = ixs.next();\n    const y = iys.next();\n    if (x.done && y.done) {\n      // All iterables exhausted\n      return;\n    } else {\n      yield [!x.done ? x.value : filler_, !y.done ? y.value : filler_];\n    }\n  }\n}\n\n/**\n * See izipLongest2, but for three.\n */\nexport function* izipLongest3<T1, T2, T3, D = undefined>(\n  xs: Iterable<T1>,\n  ys: Iterable<T2>,\n  zs: Iterable<T3>,\n  filler?: D,\n): Iterable<[T1 | D, T2 | D, T3 | D]> {\n  const filler_ = filler as D;\n  const ixs = iter(xs);\n  const iys = iter(ys);\n  const izs = iter(zs);\n  for (;;) {\n    const x = ixs.next();\n    const y = iys.next();\n    const z = izs.next();\n    if (x.done && y.done && z.done) {\n      // All iterables exhausted\n      return;\n    } else {\n      yield [!x.done ? x.value : filler_, !y.done ? y.value : filler_, !z.done ? z.value : filler_];\n    }\n  }\n}\n\n/**\n * Like the other izips (`izip`, `izip3`, etc), but generalized to take an\n * unlimited amount of input iterables.  Think `izip(*iterables)` in Python.\n *\n * **Note:** Due to Flow type system limitations, you can only \"generially\" zip\n * iterables with homogeneous types, so you cannot mix types like <A, B> like\n * you can with izip2().\n */\nexport function* izipMany<T>(...iters: Iterable<T>[]): Iterable<T[]> {\n  // Make them all iterables\n  const iterables = iters.map(iter);\n\n  for (;;) {\n    const heads: Array<IteratorResult<T, undefined>> = iterables.map((xs) => xs.next());\n    if (every(heads, (h) => !h.done)) {\n      yield heads.map((h) => h.value as T);\n    } else {\n      // One of the iterables exhausted\n      return;\n    }\n  }\n}\n\n/**\n * Return successive `r`-length permutations of elements in the iterable.\n *\n * If `r` is not specified, then `r` defaults to the length of the iterable and\n * all possible full-length permutations are generated.\n *\n * Permutations are emitted in lexicographic sort order.  So, if the input\n * iterable is sorted, the permutation tuples will be produced in sorted order.\n *\n * Elements are treated as unique based on their position, not on their value.\n * So if the input elements are unique, there will be no repeat values in each\n * permutation.\n */\nexport function* permutations<T>(iterable: Iterable<T>, r?: number): Iterable<T[]> {\n  const pool = Array.from(iterable);\n  const n = pool.length;\n  const x = r === undefined ? n : r;\n\n  if (x > n) {\n    return;\n  }\n\n  let indices: number[] = Array.from(range(n));\n  const cycles: number[] = Array.from(range(n, n - x, -1));\n  const poolgetter = (i: number) => pool[i];\n\n  yield indices.slice(0, x).map(poolgetter);\n\n  while (n > 0) {\n    let cleanExit = true;\n    for (const i of range(x - 1, -1, -1)) {\n      cycles[i] -= 1;\n      if (cycles[i] === 0) {\n        indices = indices\n          .slice(0, i)\n          .concat(indices.slice(i + 1))\n          .concat(indices.slice(i, i + 1));\n        cycles[i] = n - i;\n      } else {\n        const j: number = cycles[i];\n\n        const [p, q] = [indices[indices.length - j], indices[i]];\n        indices[i] = p;\n        indices[indices.length - j] = q;\n        yield indices.slice(0, x).map(poolgetter);\n        cleanExit = false;\n        break;\n      }\n    }\n\n    if (cleanExit) {\n      return;\n    }\n  }\n}\n\n/**\n * Returns an iterator that produces values over and over again.  Runs\n * indefinitely unless the times argument is specified.\n */\nexport function* repeat<T>(thing: T, times?: number): Iterable<T> {\n  if (times === undefined) {\n    for (;;) {\n      yield thing;\n    }\n  } else {\n    for (const _ of range(times)) {\n      yield thing;\n    }\n  }\n}\n\n/**\n * Returns an iterator that produces elements from the iterable as long as the\n * predicate is true.\n */\nexport function* takewhile<T>(iterable: Iterable<T>, predicate: Predicate<T>): Iterable<T> {\n  const it = iter(iterable);\n  let res: IteratorResult<T>;\n  while (!(res = it.next()).done) {\n    const value = res.value;\n    if (!predicate(value)) return; // early return, so we cannot use for..of loop!\n    yield value;\n  }\n}\n\nexport function zipLongest2<T1, T2, D>(xs: Iterable<T1>, ys: Iterable<T2>, filler?: D): Array<[T1 | D, T2 | D]> {\n  return Array.from(izipLongest2(xs, ys, filler));\n}\n\nexport function zipLongest3<T1, T2, T3, D>(\n  xs: Iterable<T1>,\n  ys: Iterable<T2>,\n  zs: Iterable<T3>,\n  filler?: D,\n): Array<[T1 | D, T2 | D, T3 | D]> {\n  return Array.from(izipLongest3(xs, ys, zs, filler));\n}\n\nexport const izipLongest = izipLongest2;\nexport const zipLongest = zipLongest2;\n\nexport function zipMany<T>(...iters: Iterable<T>[]): T[][] {\n  return Array.from(izipMany(...iters));\n}\n","import { count, ifilter, imap, izip, izip3, takewhile } from \"./itertools\";\nimport type { Predicate, Primitive } from \"./types\";\nimport { identityPredicate, keyToCmp, numberIdentity, primitiveIdentity } from \"./utils\";\n\n/**\n * Returns the first item in the iterable for which the predicate holds, if\n * any. If no predicate is given, it will return the first value returned by\n * the iterable.\n */\nexport function find<T>(iterable: Iterable<T>, keyFn?: Predicate<T>): T | undefined {\n  const it = iter(iterable);\n  if (keyFn === undefined) {\n    const value = it.next();\n    return value.done ? value.value : value.value;\n  } else {\n    let res: IteratorResult<T>;\n    while (!(res = it.next()).done) {\n      const value = res.value;\n      if (keyFn(value)) {\n        return value;\n      }\n    }\n    return undefined;\n  }\n}\n\n/**\n * Returns true when all of the items in iterable are truthy.  An optional key\n * function can be used to define what truthiness means for this specific\n * collection.\n *\n * Examples:\n *\n *     all([])                           // => true\n *     all([0])                          // => false\n *     all([0, 1, 2])                    // => false\n *     all([1, 2, 3])                    // => true\n *\n * Examples with using a key function:\n *\n *     all([2, 4, 6], n => n % 2 === 0)  // => true\n *     all([2, 4, 5], n => n % 2 === 0)  // => false\n *\n */\nexport function every<T>(iterable: Iterable<T>, keyFn: Predicate<T> = identityPredicate): boolean {\n  for (const item of iterable) {\n    if (!keyFn(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns true when some of the items in iterable are truthy.  An optional key\n * function can be used to define what truthiness means for this specific\n * collection.\n *\n * Examples:\n *\n *     some([])                           // => false\n *     some([0])                          // => false\n *     some([0, 1, null, undefined])      // => true\n *\n * Examples with using a key function:\n *\n *     some([1, 4, 5], n => n % 2 === 0)  // => true\n *     some([{name: 'Bob'}, {name: 'Alice'}], person => person.name.startsWith('C'))  // => false\n *\n */\nexport function some<T>(iterable: Iterable<T>, keyFn: Predicate<T> = identityPredicate): boolean {\n  for (const item of iterable) {\n    if (keyFn(item)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Alias of `every()`.\n */\nexport const all = every;\n\n/**\n * Alias of `some()`.\n */\nexport const any = some;\n\n/**\n * Returns true when any of the items in the iterable are equal to the target object.\n *\n * Examples:\n *\n *     contains([], 'whatever')         // => false\n *     contains([3], 42)                // => false\n *     contains([3], 3)                 // => true\n *     contains([0, 1, 2], 2)           // => true\n *\n */\nexport function contains<T>(haystack: Iterable<T>, needle: T): boolean {\n  return some(haystack, (x) => x === needle);\n}\n\n/**\n * Returns an iterable of enumeration pairs.  Iterable must be a sequence, an\n * iterator, or some other object which supports iteration.  The elements\n * produced by returns a tuple containing a counter value (starting from 0 by\n * default) and the values obtained from iterating over given iterable.\n *\n * Example:\n *\n *     import { enumerate } from 'itertools';\n *\n *     console.log([...enumerate(['hello', 'world'])]);\n *     // [0, 'hello'], [1, 'world']]\n */\nexport function* enumerate<T>(iterable: Iterable<T>, start = 0): Iterable<[number, T]> {\n  let index: number = start;\n  for (const value of iterable) {\n    yield [index++, value];\n  }\n}\n\n/**\n * Non-lazy version of ifilter().\n */\nexport function filter<T, N extends T>(iterable: Iterable<T>, predicate: (item: T) => item is N): N[];\nexport function filter<T>(iterable: Iterable<T>, predicate: Predicate<T>): T[];\nexport function filter<T>(iterable: Iterable<T>, predicate: Predicate<T>): T[] {\n  return Array.from(ifilter(iterable, predicate));\n}\n\n/**\n * Returns an iterator object for the given iterable.  This can be used to\n * manually get an iterator for any iterable datastructure.  The purpose and\n * main use case of this function is to get a single iterator (a thing with\n * state, think of it as a \"cursor\") which can only be consumed once.\n */\nexport function iter<T>(iterable: Iterable<T>): IterableIterator<T> {\n  // class SelfIter implements IterableIterator<T> {\n  //     #iterator: Iterator<T>;\n  //     constructor(orig: Iterable<T>) {\n  //         this.#iterator = orig[Symbol.iterator]();\n  //     }\n  //     [Symbol.iterator]() {\n  //         return this;\n  //     }\n  //     next() {\n  //         return this.#iterator.next();\n  //     }\n  // }\n  // return new SelfIter(iterable);\n\n  return iterable[Symbol.iterator]() as IterableIterator<T>;\n  //                                 ^^^^^^^^^^^^^^^^^^^^^^ Not safe!\n}\n\n/**\n * Non-lazy version of imap().\n */\nexport function map<T, V>(iterable: Iterable<T>, mapper: (item: T) => V): V[] {\n  return Array.from(imap(iterable, mapper));\n}\n\n/**\n * Return the largest item in an iterable.  Only works for numbers, as ordering\n * is pretty poorly defined on any other data type in JS.  The optional `keyFn`\n * argument specifies a one-argument ordering function like that used for\n * sorted().\n *\n * If the iterable is empty, `undefined` is returned.\n *\n * If multiple items are maximal, the function returns either one of them, but\n * which one is not defined.\n */\nexport function max<T>(iterable: Iterable<T>, keyFn: (item: T) => number = numberIdentity): T | undefined {\n  return reduce2(iterable, (x, y) => (keyFn(x) > keyFn(y) ? x : y));\n}\n\n/**\n * Return the smallest item in an iterable.  Only works for numbers, as\n * ordering is pretty poorly defined on any other data type in JS.  The\n * optional `keyFn` argument specifies a one-argument ordering function like\n * that used for sorted().\n *\n * If the iterable is empty, `undefined` is returned.\n *\n * If multiple items are minimal, the function returns either one of them, but\n * which one is not defined.\n */\nexport function min<T>(iterable: Iterable<T>, keyFn: (item: T) => number = numberIdentity): T | undefined {\n  return reduce2(iterable, (x, y) => (keyFn(x) < keyFn(y) ? x : y));\n}\n\n/**\n * Internal helper for the range function\n */\nfunction range_(start: number, stop: number, step: number): Iterable<number> {\n  const counter = count(start, step);\n  const pred = step >= 0 ? (n: number) => n < stop : (n: number) => n > stop;\n  return takewhile(counter, pred);\n}\n\n/**\n * Returns an iterator producing all the numbers in the given range one by one,\n * starting from `start` (default 0), as long as `i < stop`, in increments of\n * `step` (default 1).\n *\n * `range(a)` is a convenient shorthand for `range(0, a)`.\n *\n * Various valid invocations:\n *\n *     range(5)           // [0, 1, 2, 3, 4]\n *     range(2, 5)        // [2, 3, 4]\n *     range(0, 5, 2)     // [0, 2, 4]\n *     range(5, 0, -1)    // [5, 4, 3, 2, 1]\n *     range(-3)          // []\n *\n * For a positive `step`, the iterator will keep producing values `n` as long\n * as the stop condition `n < stop` is satisfied.\n *\n * For a negative `step`, the iterator will keep producing values `n` as long\n * as the stop condition `n > stop` is satisfied.\n *\n * The produced range will be empty if the first value to produce already does\n * not meet the value constraint.\n */\n\nexport function range(stop: number): Iterable<number>;\nexport function range(start: number, stop: number, step?: number): Iterable<number>;\nexport function range(startOrStop: number, definitelyStop?: number, step = 1): Iterable<number> {\n  if (definitelyStop !== undefined) {\n    return range_(startOrStop /* as start */, definitelyStop, step);\n  } else {\n    return range_(0, startOrStop /* as stop */, step);\n  }\n}\n\n/**\n * Apply function of two arguments cumulatively to the items of sequence, from\n * left to right, so as to reduce the sequence to a single value.  For example:\n *\n *     reduce([1, 2, 3, 4, 5], (x, y) => x + y, 0)\n *\n * calculates\n *\n *     (((((0+1)+2)+3)+4)+5)\n *\n * The left argument, `x`, is the accumulated value and the right argument,\n * `y`, is the update value from the sequence.\n *\n * **Difference between `reduce()` and `reduce\\_()`**:  `reduce()` requires an\n * explicit initializer, whereas `reduce_()` will automatically use the first\n * item in the given iterable as the initializer.  When using `reduce()`, the\n * initializer value is placed before the items of the sequence in the\n * calculation, and serves as a default when the sequence is empty.  When using\n * `reduce_()`, and the given iterable is empty, then no default value can be\n * derived and `undefined` will be returned.\n */\nexport function reduce<T>(iterable: Iterable<T>, reducer: (agg: T, item: T, index: number) => T): T | undefined;\nexport function reduce<T, O>(iterable: Iterable<T>, reducer: (agg: O, item: T, index: number) => O, start: O): O;\nexport function reduce<T, O>(\n  iterable: Iterable<T>,\n  reducer: ((agg: T, item: T, index: number) => T) | ((agg: O, item: T, index: number) => O),\n  start?: O,\n): O | (T | undefined) {\n  if (start === undefined) {\n    return reduce2(iterable, reducer as (agg: T, item: T, index: number) => T);\n  } else {\n    return reduce3(iterable, reducer as (agg: O, item: T, index: number) => O, start);\n  }\n}\n\nfunction reduce3<T, O>(iterable: Iterable<T>, reducer: (agg: O, item: T, index: number) => O, start: O): O {\n  let output = start;\n  let index = 0;\n  for (const item of iterable) {\n    output = reducer(output, item, index++);\n  }\n  return output;\n}\n\nfunction reduce2<T>(iterable: Iterable<T>, reducer: (agg: T, item: T, index: number) => T): T | undefined {\n  const it = iter(iterable);\n  const start = find(it);\n  if (start === undefined) {\n    return undefined;\n  } else {\n    return reduce3(it, reducer, start);\n  }\n}\n\n/**\n * Return a new sorted list from the items in iterable.\n *\n * Has two optional arguments:\n *\n * * `keyFn` specifies a function of one argument providing a primitive\n *   identity for each element in the iterable.  that will be used to compare.\n *   The default value is to use a default identity function that is only\n *   defined for primitive types.\n *\n * * `reverse` is a boolean value.  If `true`, then the list elements are\n *   sorted as if each comparison were reversed.\n */\nexport function sorted<T>(\n  iterable: Iterable<T>,\n  keyFn: (item: T) => Primitive = primitiveIdentity,\n  reverse = false,\n): T[] {\n  const result = Array.from(iterable);\n  result.sort(keyToCmp(keyFn)); // sort in-place\n\n  if (reverse) {\n    result.reverse(); // reverse in-place\n  }\n\n  return result;\n}\n\n/**\n * Sums the items of an iterable from left to right and returns the total.  The\n * sum will defaults to 0 if the iterable is empty.\n */\nexport function sum(iterable: Iterable<number>): number {\n  return reduce(iterable, (x, y) => x + y, 0);\n}\n\n/**\n * See izip.\n */\nexport function zip<T1, T2>(xs: Iterable<T1>, ys: Iterable<T2>): Array<[T1, T2]> {\n  return Array.from(izip(xs, ys));\n}\n\n/**\n * See izip3.\n */\nexport function zip3<T1, T2, T3>(xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Array<[T1, T2, T3]> {\n  return Array.from(izip3(xs, ys, zs));\n}\n","import { find } from \"./builtins\";\nimport { ifilter, imap } from \"./itertools\";\nimport { flatten } from \"./more-itertools\";\nimport type { Predicate } from \"./types\";\n\nfunction isNullish<T>(x: T): x is NonNullable<T> {\n  return x != null;\n}\n\nfunction isDefined<T>(x: T): boolean {\n  return x !== undefined;\n}\n\n/**\n * Returns an iterable, filtering out any \"nullish\" values from the iterable.\n *\n *     >>> compact([1, 2, undefined, 3, null])\n *     [1, 2, 3]\n *\n * For an eager version, @see compact().\n */\nexport function icompact<T>(iterable: Iterable<T | null | undefined>): Iterable<T> {\n  return ifilter(iterable, isNullish);\n}\n\n/**\n * Returns an array, filtering out any \"nullish\" values from the iterable.\n *\n *     >>> compact([1, 2, undefined, 3, null])\n *     [1, 2, 3]\n *\n * For a lazy version, @see icompact().\n */\nexport function compact<T>(iterable: Iterable<T | null | undefined>): T[] {\n  return Array.from(icompact(iterable));\n}\n\n/**\n * Removes all \"nullish\" values from the given object. Returns a new object.\n *\n *     >>> compactObject({ a: 1, b: undefined, c: 0, d: null })\n *     { a: 1, c: 0 }\n *\n */\nexport function compactObject<K extends string, V>(obj: Record<K, V | null | undefined>): Record<K, V> {\n  const result = {} as Record<K, V>;\n  for (const [key, value_] of Object.entries(obj)) {\n    const value = value_ as V | null | undefined;\n    if (value != null) {\n      result[key as K] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Almost an alias of find(). There only is a difference if no key fn is\n * provided. In that case, `find()` will return the first item in the iterable,\n * whereas `first()` will return the first non-`undefined` value in the\n * iterable.\n */\nexport function first<T>(iterable: Iterable<T>, keyFn?: Predicate<T>): T | undefined {\n  return find(iterable, keyFn ?? isDefined);\n}\n\n/**\n * Returns 0 or more values for every value in the given iterable.\n * Technically, it's just calling map(), followed by flatten(), but it's a very\n * useful operation if you want to map over a structure, but not have a 1:1\n * input-output mapping.  Instead, if you want to potentially return 0 or more\n * values per input element, use flatmap():\n *\n * For example, to return all numbers `n` in the input iterable `n` times:\n *\n *     >>> const repeatN = n => repeat(n, n);\n *     >>> [...flatmap([0, 1, 2, 3, 4], repeatN)]\n *     [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]  // note: no 0\n *\n */\nexport function flatmap<T, S>(iterable: Iterable<T>, mapper: (item: T) => Iterable<S>): Iterable<S> {\n  return flatten(imap(iterable, mapper));\n}\n"],"mappings":"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","names":["count","first","grouper","heads","enumerate"]}